\documentclass[14pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=0.6in]{geometry}
\usepackage[document]{ragged2e}
\usepackage{enumitem}
\usepackage{textcomp}
\usepackage{lmodern}
\usepackage{easylist}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{setspace}
\setstretch{1.25}
\usepackage[most]{tcolorbox}
\usepackage{fancyhdr}

\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\fancyhead[]{}
\fancyfoot[L]{Entry No: }

% set the default code style
\lstset{
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{green}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red} % string color
}
\newtcolorbox{myframe}[1][]{
  enhanced,
  arc=0pt,
  outer arc=0pt,
  colback=white,
  boxrule=0.8pt,
  #1
}

\begin{document}
\large
EFC004U1M: Data Structures and Algorithms (IIT Jammu, Semester-II-2019-20)

\begin{flushright}
Mid Term Examination\\
\vspace{1em}
Name: \underline{\hspace{6cm}} \\
\vspace{1em}
Entry Number: \underline{\hspace{6cm}} \\
\end{flushright}

\RaggedRight

There are 5 questions for a total of 16 points. 
\hfill Maximum Score: 15 points \\*
Answer in the spaces/box provided. \\* Write your \textbf{Entry No.} at bottom left on each page.
\hfill Maximum Time: 2 hours
\noindent\rule{\textwidth}{1pt}

\section{State True or False:}
\begin{enumerate}[label=\alph*)]
    \item (\textonequarter\ point) A function can return any type of value in C++ regardless of the type specified in \\* declaration.
    \hfill (a) \underline{\hspace{2cm}False\hspace{2cm}}
    
    \item (\textonequarter\ point) You are given a snippet of code declaring some variables:
    \begin{lstlisting}[language=C++, title={Part (b)}]
    int x = 20;
    int y = 10;
    int z = 4;
    \end{lstlisting}
    The expression \underline{$!(x + y > 8*z)$} evaluates to 
    \hfill (b) \underline{\hspace{2cm}True\hspace{2cm}}
    
    \item (\textonequarter\ point) A pretest loop is one in which the conditional statement is checked before \\* the execution of the block of code. While loop is NOT a pretest loop.\ \hfill (c) \underline{\hspace{1cm}False\hspace{1cm}}
    
    \item (\textonequarter\ point) If a function returns no value, the return type must be declared as void. \\*
    \hfill (d) \underline{\hspace{2cm}True\hspace{2cm}}
    
    \item (\textonequarter\ point) A pointer variable can't point to other pointer variables. \\*
    \hfill (e) \underline{\hspace{2cm}False\hspace{2cm}}
    
    \item (\textonequarter\ point) All objects of a class share all data members, private and public, of a class. \\*
    \hfill (f) \underline{\hspace{2cm}False\hspace{2cm}}
    
    \item (\textonequarter\ point) A pointer stores the address of the variable whereas a reference is just an alias for that variable.
    \hfill (g) \underline{\hspace{2cm}True\hspace{2cm}}
    
    \item (\textonequarter\ point) The tightest upper bound that represents the \textbf{no. of swaps} required to sort $n$ numbers using \textbf{selection sort} is $O(n^2)$. In selection sort, we first pick the min. element and swap with the first position, then the $2^{nd}$ min is swapped with $2^{nd}$ position and so on. \\*
    \hfill (h) \underline{\hspace{2cm}False\hspace{2cm}}
\end{enumerate}

\section{Fill in the blanks:}
\begin{enumerate}[label=\alph*)]
    \item (\textonequarter\ point) The type of 17.23 in C++ can be \underline{\hspace{2cm}float or double\hspace{2cm}}.
    
    \item (\textonequarter\ point) If originally $x = 1$ and $y = 0.5$, the value of $answer$ after executing the following snippet of code will be \underline{\hspace{2cm}$-5$\hspace{2cm}}.
    \begin{lstlisting}[language=C++, title={Part (b)}]
    int answer;
    x *= 5;
    answer = -x + (-y);
    \end{lstlisting}
    
    \item (\textonequarter\ point) $int\ arr[4][3]$ is an integer array with \underline{\hspace{2cm}$48$\hspace{2cm}} bytes of memory. (int takes 32 bits of size).
    
    \item (\textonequarter\ point) Find the asymptotic relationship ($\mathcal{O}$/$\Omega$/$\Theta$). $n^k$ is \underline{\hspace{0.25cm}$\mathcal{O}$\hspace{0.25cm}}($c^n$). Assume that $k >= 1$ and $c > 1$ are constants.
    
    \item (\textonequarter\ point) A sorting algorithm takes 1 second to sort 1,000 items on your local machine. The time it will take to sort 10,000 items if you believe that the algorithm takes time proportional to $n^2$ is \underline{\hspace{1cm}$100$ seconds\hspace{1cm}}
    
    \item (\textonequarter\ point)
    The following function computes the maximum value contained in an integer array $p[]$ of size $n\ (n \geq 1)$. Fill the missing loop condition.
    \begin{lstlisting}[language=C++, title={Part (f)}]
    int max(int *p, int n) {
        int a = 0, b = n - 1;
        while (a != b) {
            if (p[a] <= p[b]) {a = a + 1;}
            else              {b = b - 1;}
        }
        return p[a];
    }
    \end{lstlisting}
    
\end{enumerate}

\section{Find the output: (answer in the box)}
\begin{enumerate}[label=\alph*)]
    \item (\textonequarter\ point)
    \begin{lstlisting}[language=C++, title={Part (a)}]
    int ar[4] = {2, 4, 6, 8};
    ar[0] = 27;
    ar[3] = ar[2];
    cout << ar[0] << " and " << ar[3] << endl;
    \end{lstlisting}
    \begin{myframe}[width=500pt,height=30pt,top=2pt,bottom=2.5pt,left=200pt,right=200pt,arc=10pt,auto outer arc]
    $27$ and $6$
    \end{myframe}
    
    \item (\textonequarter\ point)
    \begin{lstlisting}[language=C++, title={Part (b)}]
    class Parent {
    public:
        void PPrint() {
            cout << "Parent print ";
        }
    };
    class Child: public Parent {
    public:
        void CPrint() {
            cout << "Child print ";
        }
    };
    int main () {
        Child c;
        c.PPrint();
    }
    \end{lstlisting}
    \begin{myframe}[width=500pt,height=30pt,top=2pt,bottom=2.5pt,left=200pt,right=200pt,arc=10pt,auto outer arc]
    Parent print
    \end{myframe}
    \item (\textonequarter\ point)
    \begin{lstlisting}[language=C++, title={Part (c)}]
    #include <iostream>
    using namespace std;
    int main () {
        int a[4][5] = {{1, 2, 3, 4, 5},
                      {6, 7, 8, 9, 10},
                      {11, 12, 13, 14, 15},
                      {16, 17, 18, 19, 20}};
        cout << *(*(a+**a+2)+3) << endl;
    }
    \end{lstlisting}
    \begin{myframe}[width=500pt,height=20pt,top=2pt,bottom=2.5pt,left=200pt,right=200pt,arc=10pt,auto outer arc]
    $19$
    \end{myframe}
    
    \item (\textonequarter\ point)
    Consider the following C++ functions: \\*
    \noindent\begin{minipage}{.45\textwidth}
    \begin{lstlisting}[language=C++, title={Part (d) - I}]
    int tob(int b, int* arr) {
        int i;
        for (i = 0; b > 0; ++i){
            if (b % 2) 
                arr[i] = 1;
            else
                arr[i] = 0;
            b = b/2;
        }
        return (i);
    }
    \end{lstlisting}
    \end{minipage}\hfill
    \begin{minipage}{.45\textwidth}
    \begin{lstlisting}[language=C++, title={Part (d) - II}]
    int pp(int a, int b) {
        int arr[20];
        int i, tot = 1, ex, len;
        ex = a;
        len = tob(b, arr);
        for (i = 0; i < len; ++i) {
            if (arr[i] == 1) {
                tot = tot * ex;
            }
            ex = ex * ex;
        }
        return (tot);
    }
    \end{lstlisting}
    \end{minipage}
    \\* The value returned by $pp(2, 10)$ is: \\*
    \begin{myframe}[width=500pt,height=20pt,top=2pt,bottom=2.5pt,left=200pt,right=200pt,arc=10pt,auto outer arc]
    $1024$
    \end{myframe}
\end{enumerate}

\section{Fix the bug in the following: (mention line number(s) and the fix)}
\begin{enumerate}[label=\alph*]
    \item (\textonequarter\ point)
    \begin{lstlisting}[language=C++, title={Part (a)}]
    class Quiz {
        int score;
    }
    int main () {
        Quiz mid_term;
        cout << mid_term.score << endl;
        return 0;
    }
    \end{lstlisting}
    \begin{myframe}[width=500pt,height=50pt,top=2pt,bottom=2.5pt,left=2pt,right=2pt,arc=10pt,auto outer arc]
    In line 2, the variable \textbf{score} must be declared public to access it in the \textbf{main} function. \\*
    An alternative is to include a public getter function and modify line 6 to use it.
    \end{myframe}
    
    \item (\textonequarter\ point)
    \begin{lstlisting}[language=C++, title={Part (b)}]
    void mystery(int *ptra, int *ptrb) {
        int *temp;
        temp = ptrb;
        ptrb = ptra;
        ptra = temp;
    }
    int main () {
        int a = 2020, b = 0, c = 4, d = 42;
        mystery(a, b);
        if (a < c) {
            mystery(c, a);
        }
        mystery(a, d);
        cout << a << endl;
    }
    \end{lstlisting}
    \begin{myframe}[width=500pt,height=50pt,top=2pt,bottom=2.5pt,left=2pt,right=2pt,arc=10pt,auto outer arc]
    In lines $9$, $11$ and $13$, the calls to the function \textbf{mystery} are incorrect. Since input arguments are pointers, we must use reference ($\&$) operator before the variables when calling it.
    \end{myframe}
    
\end{enumerate}

\section{Answer the following:}
\begin{enumerate}[label=\alph*)]
    \item ($2$\ points)
    Consider the following C++ code segment. Let $T(n)$ denote the no. of times the for loop is executed by the program on input $n$. Which of the following claims are true? (Also give explanation for each).
    \begin{lstlisting}[language=C++, title={Part (a)}]
    int isPrime(int n) {
        for (int i = 2; i <= sqrt(n); ++i) {
            if (n % i == 0) {
                return 0;
            }
        }
        return 1;
    }
    \end{lstlisting}
    \begin{enumerate}[label=\roman*]
        \item $T(n) = \mathcal{O}(\sqrt{n})$
        \item $T(n) = \Omega(\sqrt{n})$
        \item $T(n) = \Omega(1)$
        \item $T(n) = \mathcal{O}(n)$
    \end{enumerate}
    \begin{myframe}[width=500pt,height=340pt,top=2pt,bottom=2.5pt,left=2pt,right=2pt,arc=10pt,auto outer arc]
    The claims i), iii) and iv) are correct. \\*
    \begin{enumerate}[label=\roman*]
        \item $T(n) = \mathcal{O}(\sqrt{n})$ \\*
        The loop in line 2 runs till a maximum of $\sqrt{n}$ times, and since Big-O Notation gives an upper bound, the claim is \textbf{true}.
        \item $T(n) = \Omega(\sqrt{n})$ \\*
        Since Big-Omega notation gives a lower bound to the running time, the claim is \textbf{false}. Consider an input, say $n = 1000000$. The loop runs only for $1$ iteration $(i = 2)$ and then breaks due to statement $4$ being executed.
        \item $T(n) = \Omega(1)$ \\*
        The claim is \textbf{true} since atleast the statement $7$ gets executed for any instance of $n$.
        \item $T(n) = \mathcal{O}(n)$ \\*
        Since $T(n) = \mathcal{O}(\sqrt{n})$ as established in claim i) and we can prove that $\sqrt n = \mathcal{O}(n)$.
        \[ \sqrt{n} <= 1\times n, \forall n \geq 1\]
        Thus, $c = n_{0} = 1$. Hence, $T(n) = \mathcal{O}(n)$. So, the claim is \textbf{true}.
        
    \end{enumerate}
    
    \end{myframe}
    
    \item ($2$\ points)
    Write a function to perform integer division without using either the $/$ or $*$ operators. Your function should take in two arguments, the numerator and the denominator. It returns the integer quotient. Assume that both inputs to the function are positive. \\*
    
    \begin{myframe}[width=500pt,height=200pt,top=2pt,bottom=2.5pt,left=2pt,right=2pt,arc=10pt,auto outer arc]
    \begin{lstlisting}[language=C++, title={Part (b)}]
    int get_quotient(int numerator, int denominator) {
        int result = 0;
        int num = numerator;
        while (num >= denominator) {
            ++result;
            num -= denominator;
        }
        return result;
    }
    \end{lstlisting}
    \end{myframe}
    \item ($2$\ points)
    Suppose the following algorithm is used to evaluate the polynomial \\*
    \[p(x) = a_{n}x^{n} + a_{n-1}x^{n-1} + \cdots + a_{1}x + a_{0} \]
    \begin{lstlisting}[language=C++, title={Part (c) - I}]
    int p = a[0];
    int xpower = 1;
    for (int i = 1; i <= n; ++i) {
        xpower = x*xpower;
        p = p + a[i]*xpower;
    }
    \end{lstlisting}
    What is the no. of multiplications done in the worst-case? Also, how many additions? \\*
    \begin{myframe}[width=500pt,height=80pt,top=2pt,bottom=2.5pt,left=2pt,right=2pt,arc=10pt,auto outer arc]
    The no. of multiplications done are $2n$ in any case, one in line $4$, other in line $5$ which are repeated $n$ times, thus $2n$. \\*
    The no. of additions performed are $n$, which are done in line $5$ over $n$ iterations of the loop in line $3$.
    \end{myframe}
    
    Now, consider the following algorithm:
    \begin{lstlisting}[language=C++, title={Part (c) - II}]
    int p = 0;
    for (int i = n; i >= 0; --i) {
        p = (p*x) + a[i];
    }
    \end{lstlisting}
    Does the above algorithm evaluate the polynomial correctly for a given value of $x$ and the coefficients $a[0 \cdots n]$? How many additions and multiplications does it require? What are the time complexities of both the algorithms? \\*
    \begin{myframe}[width=500pt,height=130pt,top=2pt,bottom=2.5pt,left=2pt,right=2pt,arc=10pt,auto outer arc]
    Yes, the above algorithm performs correct polynomial evolution as:
    \[ p = a_{0} + x(a_{1} + x(a_{2} + x(a_{3} + \cdots + x(a_{n-1} + x \cdot a_{n})\cdots))) = p(x)\]
    It requires $n$ additions and $n$ multiplications. \\*
    The time complexities of both the algorithms are $\mathcal{O}(n)$ as the loop in both of them runs $n$ times.
    \end{myframe}
    
    \item ($3$\ points)
    You are given an array $A[0 \cdots (n-1)]$, where each element of the array represents a vote in the election. Assume each vote is given as an integer representing the ID of the chosen candidate. \textbf{Write a function that determines who wins the election (the ID of the winning candidate)}. Assume the inputs to the function are the integer array and n (no. of votes), and it returns the integer ID of the winning candidate. \\*
    Also, analyze the time complexity of your solution. \\*
     \begin{myframe}[width=500pt,height=400pt,top=2pt,bottom=2.5pt,left=2pt,right=2pt,arc=10pt,auto outer arc]
    \begin{lstlisting}[language=C++, title={Part (b)}]
    int find_winner(int votes[], int count) {
        int max_votes = 0;
        int winner_candidate_id;
        for (int idx = 0; idx < count; ++idx) {
            int candidate = votes[idx];
            int total_votes = 0;
            for (int i = 0; i < count; ++i) {
                if (votes[i] == candidate) {
                    ++total_votes;
                }
            }
            if (total_votes > max_votes) {
                max_votes = total_votes;
                winner_candidate_id = candidate;
            }
        }
        return winner_candidate_id;
    }
    \end{lstlisting}
    Time Complexity of the above solution is $\mathcal{O}(n^2)$
    \end{myframe}
    Can you improve the complexity of your solution? Assume that you know sorting an array of size $n$ takes $O(n\ logn)$ time. Explain your new algorithm. (No need to write code).
    
    \begin{myframe}[width=500pt,height=130pt,top=2pt,bottom=2.5pt,left=2pt,right=2pt,arc=10pt,auto outer arc]
    We can improve the complexity of our solution by using sorting. We can sort the \textbf{votes} array. \\*
    Now, the duplicate values in the array will come together. So, we can maintain the count of votes of current candidate as we scan the array sequentially. \\*
    As soon as the candidate changes in the votes array, we check if current vote count is greater than the max vote count, and update the winner accordingly.
    \end{myframe}
    
    \item ($1$\ point)
    Solve the following recurrence relation and write the exact value of $T(n).$ Show calculations. (DO NOT USE MASTER'S THEOREM).
    \[T(n) = 2 \times T(n/2) + n^2; \ T(1) = 1 \]
    (assume that $n$ is a power of $2$). Finally, express $T(n)$ in Big-O notation.
    
    \begin{myframe}[width=500pt,height=320pt,top=2pt,bottom=2.5pt,left=2pt,right=2pt,arc=10pt,auto outer arc]
    \begin{align*}
      \hspace{2em}&\hspace{-2em} T(n) \\
      &= 2 \cdot T(n/2) + n^2 \\
      &= 2 \cdot (2 \cdot T(n/2^{2}) + (n/2)^{2}) + n^2 \\
      &= 2^2 \cdot T(n/2^2) + n^2 \cdot (1 + 1/2) \\
      &= 2^3 \cdot T(n/2^3) + n^2 \cdot (1 + 1/2 + 1/2^2) \\
      &\vdots\\
      &= 2^k \cdot T(n/2^k) + n^2 \cdot (1 + 1/2 + \cdots + 1/2^{k-1}) \\
      &\vdots\\
      &= 2^{logn} \cdot T(n/2^{logn}) + n^2 \cdot (1 + 1/2 + \cdots + 1/2^{logn - 1}) \\
      &= n \cdot T(1) + n^2 \cdot \frac{1 - 1/n}{1 - 1/2} \\
      &= n + 2n(n - 1) \\
      &= 2n^2 - n
    \end{align*}
    \begin{center}
    Thus, T(n) = $\mathcal{O}(n^2)$.
    \end{center}
    \end{myframe}
    
    \item ($1$\ point)
    You need to write a recurrence relation that leads to the time complexity of $\mathcal{O}(nloglogn)$. Also, write a recursive function corresponding to it. (Mention any assumptions you have made).
    \begin{myframe}[width=500pt,height=320pt,top=2pt,bottom=2.5pt,left=2pt,right=2pt,arc=10pt,auto outer arc]
    According to Master's Theorem, if the recurrence is of the form \\* $T(n) = a \cdot T(n/b) + \mathcal{O}(n^k log^p n)$ where $a \geq 1$, $b > 1$, $k \geq 0$ and $p$ is a real number. Then, 
    \begin{enumerate}
        \item If $a > b^k$, then $T(n) = \mathcal{O}(n^{log_{b}a})$
        \item If $a = b^k$, then 
        \begin{enumerate}
            \item If $p > -1$, then $T(n) = \mathcal{O}(n^{log_{b}a}log^{p+1}n)$
            \item If $p = -1$, then $T(n) = \mathcal{O}(n^{log_{b}a}log log n)$
            \item If $p < -1$, then $T(n) = \mathcal{O}(n^{log_{b}a})$
        \end{enumerate}
        \item If $a < b^k$, then
        \begin{enumerate}
            \item If $p \geq 0$, then $T(n) = \mathcal{O}(n^k log^p n)$
            \item If $p < 0$, then $T(n) = \mathcal{O}(n^k)$
        \end{enumerate}
    \end{enumerate}
    \end{myframe}
    
    \begin{myframe}[width=500pt,height=320pt,top=2pt,bottom=2.5pt,left=2pt,right=2pt,arc=10pt,auto outer arc]
    Considering the case when $a = b^k$ and $p = -1$, we get: \\*
    $T(n) = \mathcal{O}(n^{log_{b}a}log log n)$ \\*
    If we consider $b = a$ to get $log_{b}a = 1$, then $k = 1$ and $p = -1$ already. Now, since $b > 1$, let us take $b = a = 2$, thus a possible recurrence can be: \\*
    \[ T(n) = 2 \times T(n/2) + \mathcal{O}(n/logn) \]
    The recursive function can now be constructed as follows:
    \begin{lstlisting}[language=C++, title={Part (f)}]
    void recurse(int n) {
        if (n == 0) {
            return;
        }
        recurse(n/2);
        recurse(n/2);
        for (int i = 0; i < n/log(n); ++i);
    }
    \end{lstlisting}
    \end{myframe}
\end{enumerate}
\end{document}
